import 'dart:math';
//import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_database/firebase_database.dart';

class MatchmakingService {
  static Future<Map<String, dynamic>?> createMatch(String userId, {required String gameMode}) async {
    final seed = Random().nextInt(1000000);
    final matchRef = FirebaseDatabase.instance.ref('matches').push(); // Use push() for RTDB to get unique ID
    final matchId = matchRef.key!; // Get the unique ID generated by push()

    // Consolidate all match data into Realtime Database
    await matchRef.set({
      'matchId': matchId, // Store the ID within the data itself
      'seed': seed,
      'player1Id': userId,
      'player2Id': null, // Initial state
      'status': 'open',
      'createdAt': ServerValue.timestamp, // Use ServerValue.timestamp for creation time
      'player1Ready': false, // Initial ready state
      'player2Ready': false,
      'gameMode': gameMode,// Initial ready state
    });

    return {
      'matchId': matchId,
      'seed': seed,
      'gameMode': gameMode,
    };
  }

  // REVISED: Non-transactional findMatch (for Random Matchmaking)
  static Future<Map<String, dynamic>?> findMatch(String userId) async {
    final dbRef = FirebaseDatabase.instance.ref('matches');

    try {
      final snapshot = await dbRef.get();

      if (!snapshot.exists || snapshot.value == null) {
        return null; // No matches found
      }

      final matches = Map<String, dynamic>.from(snapshot.value as Map);

      // Iterate through existing matches to find an open one
      for (final entry in matches.entries) {
        final data = Map<String, dynamic>.from(entry.value);
        // Ensure not joining own match and player2Id is null
        if (data['player2Id'] == null && data['player1Id'] != userId) {
          final matchId = entry.key; // The key of the match node is the matchId

          // Attempt to claim this match
          // WARNING: This update is not atomic. A race condition could still occur here
          // if two players try to claim the same match simultaneously.
          await dbRef.child(matchId).update({
            'player2Id': userId,
          });

          // After attempting to update, re-read to confirm it was successful
          final updatedSnapshot = await dbRef.child(matchId).get();
          final updatedData = Map<String, dynamic>.from(updatedSnapshot.value as Map);

          if (updatedData['player2Id'] == userId) { // Confirmed we claimed it
            // All data is now in RTDB, no need for Firestore lookup
            final seed = updatedData['seed']; // Get seed directly from RTDB

            if (seed != null) {
              return {
                'matchId': matchId,
                'seed': seed,
              };
            }
          }
        }
      }
    } catch (e) {
      print("Error finding match (RTDB only): $e");
    }

    return null; // No open match found or successfully joined
  }
}